package com.example.demo;


import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.Setter;

import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

/**
 * for this task I will assume that we are creating service that subscribes to some message broker (e.g. kafka)
 * than it processes data, store it and provide some API to query the data it stores (get price by instrumentName)
 *
 * assumptions:
 * 1) I will assume that price feed data is being created in some distributed system, and that ID is generated by some
 * Sequencer that support ordering. So that if price1.id < price2.id  => price2 is newer data point then price1
 * (we can also use timestamp to sort data. However, synchronizing time across distributed system is daunting task)
 *
 * The amount of data we need to store in our service is no more than n * (n - 1 )  , where n is number of currencies.
 * we can easily store this amount of data in RAM. Persistent storages can be considered only for durability reasons.
 *
 * Depending on purpose of this service, instead of providing API for querying, we could push updated data back to
 * message broker (e.g kafka streams approach) and then consumers could subscribe to this topic of data.
 */

public class PriceFeedService {
    private static final double COMMISSION_RATE = 0.001; // 0.1%
    private Map<String, Price> prices = new ConcurrentHashMap<>();


    // in real world system we most likely will not use csv format but instead Prices schema with some
    // serialization/deserialization like Avro. Then, when pulling the data we will pull batch of data
    // and process each message individually. Therefore, I will assume that, even thought we use csv
    // format, each message is formatted and there are no need to expect parsing errors.
    public void onMessage(String message) {
        String[] lines = message.split("\\n");

        for (String line : lines) {
            Price price = parseMessage(line);
            Price oldPrice = prices.get(price.getInstrumentName());
            if (oldPrice != null && oldPrice.getId() > price.getId()) continue; // here we assure that we don't override
            // newer data with older one.
            applyCommission(price);
            prices.put(price.getInstrumentName(), price);
        }

    }

    private Price parseMessage(String message) {
        String[] parts = message.split(",");
        int id = Integer.parseInt(parts[0].trim());
        String instrumentName = parts[1].trim();
        double bid = Double.parseDouble(parts[2].trim());
        double ask = Double.parseDouble(parts[3].trim());
        // I have skipped parsing Date, as I don't see how this part of data can be useful for the task

        return new Price(id, instrumentName, bid, ask);
    }

    private void applyCommission(Price originalPrice) {
        double bid = originalPrice.getBid() * (1 - COMMISSION_RATE);
        double ask = originalPrice.getAsk() * (1 + COMMISSION_RATE);
        originalPrice.setBid(bid);
        originalPrice.setAsk(ask);

    }

    public Price getPrice(String instrumentName){
        return prices.get(instrumentName);
    }

}


@Getter
@Setter
@AllArgsConstructor
class Price {
    private int id;
    private String instrumentName;
    private double bid;
    private double ask;

}

